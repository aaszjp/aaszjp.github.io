[{"title":"M1 Mac 安装 CocoaPods 小结","url":"/2022/12/30/iOS/cocoapods_install_m1/","content":"\n## 一、背景\n`M1 Mac` 下 `CocoaPods` 的安装思路与 `Inter Mac` 下的安装思路一致，基本包含以下几个步骤：\n1、升级 `Ruby` 环境\n2、安装 `CocoaPods`\n3、初始化 `CocoaPods`\n但是由于\n1、 `M1 Mac` 系统权限更严格，在升级 `Ruby` 环境 `gem update --system` 时即使加了 `sudo` 也会出现报错\n```\nyou don't have write permissions for the /system/library/frameworks/ruby.framework/versions/2.6/usr/lib/ruby/gems/2.6.0 directory.\n```\n2、`CocoaPods` 自身初始化的方式发生了变化，执行 `pod setup` 仅提示 `Setup complete` 但没有实际效果\n导致操作流程有所区别。因此我把整个操作流程及中途遇到的坑及解决方案记录下来，以供查阅。\n\n## 二、原理\n`gem` 是 `Ruby` 的包管理器。从上述的权限报错可以看出，既然系统自带的 `Ruby` 不给我们权限去操作 `gem` ，那就曲线救国，我们通过 `Homebrew` 安装自己的 `Ruby` 环境，再去安装 `CocoaPods` 。\n\n## 三、流程\n#### 3.1、准备翻墙梯子\n新的安装流程需要依赖 `Homebrew` ，而 `Homebrew` 的安装需要翻墙。\n\n#### 3.2、安装 `Homebrew` \n```\n# zsh\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# bash\ncurl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh\n```\n过程可能有点久，而且中途可能会因为某些依赖包下载失败而中断安装，别怕，重试就好。\n【注】\n1、梯子需要开启全局代理，不能只开网页代理\n2、如果开了全局代理依然访问不了 `raw.githubusercontent.com` 域名，主要是 DNS  域名解析的问题，可以修改 `host` 解决，参考【附录4.1】。\n\n安装完成后，根据命令行提示，`M1 Mac` 需要添加一下环境变量。\n```\n# zsh\necho \"eval $(/opt/homebrew/bin/brew shellenv)\" >> ~/.zprofile\neval $(/opt/homebrew/bin/brew shellenv)\n\n# bash\necho \"eval $(/opt/homebrew/bin/brew shellenv)\" >> ~/.bash_profile\neval $(/opt/homebrew/bin/brew shellenv)\n```\n\n退出并重启终端，输入 `brew doctor`，出现以下文案，则表示 `Homebrew` 安装成功。\n```\nYour system is ready to brew\n```\n\n#### 3.3、安装 `Ruby` 版本管理器 `chruby` 及安装器 `ruby-install`\n```\nbrew install chruby ruby-install\n```\n\n#### 3.4、安装 `Ruby`\n```\nruby-install ruby\n```\n【注】期间可能出现无法连接 `cache.Ruby-Lang.org` 域名的情况，同样参考【附录4.1】处理即可。\n\n安装成功会有以下提示\n```\n>>> Successfully installed ruby 3.1.2 into /Users/andyzhen/.rubies/ruby-3.1.2\n```\n但是此时执行 `ruby -v` 仍会显示系统自带的版本 `2.6.x`。我们需要添加环境变量使得前面安装的 `Ruby` 版本管理器 `chruby` 生效。\n```\n# zsh\necho \"source /opt/homebrew/opt/chruby/share/chruby/chruby.sh\" >> ~/.zshrc\necho \"source /opt/homebrew/opt/chruby/share/chruby/auto.sh\" >> ~/.zshrc\necho \"chruby ruby-3.1.2\" >> ~/.zshrc\n\n# bash\necho \"source /opt/homebrew/opt/chruby/share/chruby/chruby.sh\" >> ~/.bash_profile\necho \"source /opt/homebrew/opt/chruby/share/chruby/auto.sh\" >> ~/.bash_profile\necho \"chruby ruby-3.1.2\" >> ~/.bash_profile\n```\n【注】`chruby ` 后面的 `Ruby` 版本需要填写前面安装成功提示里的版本号。\n重启终端后再执行 `ruby -v` ，会显示为我们安装的版本 `3.1.x` 。\n\n#### 3.5、安装 `CocoaPods` \n```\ngem install cocoapods\n```\n【注】如果出现报错\n```\nPermission denied @ dir_s_mkdir - /Users/YourAccount/.local/share/gem/specs\n```\n系统没有给与创建目录的权限，在前面加上 `sudo` 即可。\n安装成功后，输入 `pod --version` 会显示出我们安装的版本。\n\n#### 3.6、初始化 `CocoaPods`\n官方的方法 `pod setup` 已失效，会直接提示 `Setup completed` ，而不会有任何下载动作，执行 `pod repo list` 也显示 `0 repos` 。我们把 github 上的官方 repo 手动下载下来并放到官方指定目录下即可。\n```\ngit clone https://github.com/CocoaPods/Specs.git ~/.cocoapods/repos/trunk\n```\n下载完成后，执行 `pod repo list` 会显示\n```\ntrunk\n- Type: CDN\n- URL:  https://cdn.cocoapods.org/\n- Path: /Users/andyzhen/.cocoapods/repos/trunk\n\n1 repo\n```\n执行 `pod search sdwebimage` 也会有所显示。\n\n**至此，恭喜你，`CocoaPods` 终于安装完成了！**\n\n\n## 四、附录\n#### 4.1、通过修改 `host` 在终端访问浏览器里能访问的网站\n1、在 [https://www.ipaddress.com](https://www.ipaddress.com/) 中输入你要访问的域名\n2、选择其中一个 ipv4 的地址\n3、打开 `/etc/host` 文件，参照样例格式将 ip 和 域名添加到末尾，并保存\n```\n##\n# Host Database\n#\n# localhost is used to configure the loopback interface\n# when the system is booting.  Do not change this entry.\n##\n127.0.0.1\tlocalhost\n255.255.255.255\tbroadcasthost\n::1             localhost\n185.199.108.133 raw.githubusercontent.com\n199.232.69.178  cache.Ruby-Lang.org\n```\n\n## 五、参考\n1、[The fastest and easiest way to install Ruby on a Mac in 2022](https://www.moncefbelyamani.com/how-to-install-xcode-homebrew-git-rvm-ruby-on-mac/#start-here-if-you-choose-the-long-and-manual-route)\n2、[Install Ruby on Mac. The Definitive Guide for 2022.](https://www.moncefbelyamani.com/the-definitive-guide-to-installing-ruby-gems-on-a-mac/#install-ruby-with-a-version-manager-best-option)\n3、[You don't have write permissions for the /Library/Ruby/Gems/2.6.0 directory](https://www.moncefbelyamani.com/you-don-t-have-write-permissions-for-the-library-ruby-gems-2-6-0-directory/)\n4、[解决raw.githubusercontent.com无法访问的问题](https://blog.csdn.net/weixin_44293949/article/details/121863559)\n5、[CocoaPods安装方法-2022.05.30](https://www.jianshu.com/p/f43b5964f582)","tags":["iOS","cocoapods","m1"],"categories":["iOS"]},{"title":"iOS中的加粗字体","url":"/2022/12/30/iOS/iOS_font_bold/","content":"\n### 1. iOS系统有2个API可以设置加粗的字体\n1、常用的\n```\n[UIFont boldSystemFontOfSize:20]\n```\n2、iOS 8.2新增的\n```\n[UIFont systemFontOfSize:20 weight:UIFontWeightBold]\n```\n其中，weight 参数是个 `CGFloat` 类型的枚举值，包含以下枚举\n```\nUIFontWeightUltraLight\nUIFontWeightThin \nUIFontWeightLight \nUIFontWeightRegular \nUIFontWeightMedium \nUIFontWeightSemibold \nUIFontWeightBold \nUIFontWeightHeavy \nUIFontWeightBlack \n```\n\n那么我们常用的 `boldSystemFontOfSize ` 对应的 `weight` 是多少呢？经过测试，得到以下结果\n\n| api | weight |\n| :------: | :------: |\n| boldSystemFontOfSize | 0.3 |\n| UIFontWeightSemibold | 0.3 |\n| UIFontWeightBold | 0.4 |\n\n#### **结论：可以看到，苹果给我们开了个玩笑，系统默认的加粗字体对应的 `weight` 是 `UIFontWeightSemibold`，而不是 `UIFontWeightBold`**\n\n### 2. Hippy-iOS 中的加粗字体\nhippy 中通过 `fontWeight: \"bold\"` 设置的加粗字体，得到的 `weight` 是 0.4，源码如下：\n```\n// HippyFont.mm\n\n...\n\n#if !defined(__IPHONE_8_2) || __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_8_2\n\n// These constants are defined in iPhone SDK 8.2, but the app cannot run on\n// iOS < 8.2 unless we redefine them here. If you target iOS 8.2 or above\n// as a base target, the standard constants will be used instead.\n// These constants can only be removed when Hippy Native drops iOS8 support.\n\n#define UIFontWeightUltraLight -0.8\n#define UIFontWeightThin -0.6\n#define UIFontWeightLight -0.4\n#define UIFontWeightRegular 0\n#define UIFontWeightMedium 0.23\n#define UIFontWeightSemibold 0.3\n#define UIFontWeightBold 0.4\n#define UIFontWeightHeavy 0.56\n#define UIFontWeightBlack 0.62\n\n#endif\n\n...\n\n\n    static NSDictionary *nameToWeight;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        nameToWeight = @{\n            @\"normal\": @(UIFontWeightRegular),\n            @\"bold\": @(UIFontWeightBold),\n            @\"ultralight\": @(UIFontWeightUltraLight),\n            @\"thin\": @(UIFontWeightThin),\n            @\"light\": @(UIFontWeightLight),\n            @\"regular\": @(UIFontWeightRegular),\n            @\"medium\": @(UIFontWeightMedium),\n            @\"semibold\": @(UIFontWeightSemibold),\n            @\"bold\": @(UIFontWeightBold),\n            @\"heavy\": @(UIFontWeightHeavy),\n            @\"black\": @(UIFontWeightBlack),\n        };\n    });\n\n...\n```\n#### **结论：如果hippy需要对齐iOS系统默认的加粗字体，在设置加粗样式时需要使用 `fontWeight: \"semibold\"`**\n","tags":["iOS","UIKit"],"categories":["iOS"]},{"title":"git实用命令","url":"/2022/12/30/macOS/git_useful_cmd/","content":"\n# 常规基本操作\n- ### Git克隆某一个特定的远程分支\n```\n$ git clone -b <分支名> <仓库地址>\n```\n\t\n- ### 修改最后一次提交\n有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 --amend选项重新提交：\n```\n$ git commit --amend\n```\n\t\n- ### 抓取\n```\n// 刷新远程仓库的信息\n$ git fetch origin\n```\n\n- ### 拉取\n```\n$ git pull --rebase origin <分支名>\n```\n\t\n- ### 推送\n```\n$ git push origin <分支名>\n$ git push origin serverfix:serferfix  //上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支\n$ git push origin serverfix:awesomebranch  //把本地分支推送到某个命名不同的远程分支\n```\n--force 加上该参数，会用本地的版本信息强行覆盖远端的版本信息，配合git reset --hard HEAD^ 使用可撤销远端的commit\n\n- ### 删除远程分支\n```\n$ git push [远程名] :[分支名]\n```\n\n- ### 文件重命名\n```\n$ git mv fileA fileB\n```\n\n\n# git log\n- ### 查询某人的提交记录\n```\n$ git log  --author=””\n```\n\n- ### 查询某文件的提交记录\n```\n$ git log <file>\n```\n\n- ### 查看所有分支的提交记录\n```\ngit log --all\n```\n\t\n- ### 以类似sourcetree的图形形式查看log历史\n```\ngit log --graph --oneline --abbrev-commit\n```\n\t\n- ### 查看远程仓库的日志\n```\n$ git log origin/master --oneline -n 3\n\n\t-(n)\t\t\t\t仅显示最近的 n 条提交\n\t--since, --after \t仅显示指定时间之后的提交。\n\t--until, --before \t仅显示指定时间之前的提交。\n\t--author \t\t\t仅显示指定作者相关的提交。\n\t--committer \t\t仅显示指定提交者相关的提交。\n\t-p \t\t\t\t\t按补丁格式显示每个更新之间的差异。\n\t--stat \t\t\t\t显示每次更新的文件修改统计信息。\n\t--shortstat \t\t只显示 --stat 中最后的行数修改添加移除统计。\n\t--name-only \t\t仅在提交信息后显示已修改的文件清单。\n\t--name-status \t\t显示新增、修改、删除的文件清单。\n\t--abbrev-commit \t仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。\n\t--relative-date \t使用较短的相对时间显示（比如，“2 weeks ago”）。\n\t--graph \t\t\t显示 ASCII 图形表示的分支合并历史。\n\t--pretty \t\t\t使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。\n```\n[选项说明参考此文](http://www.open-open.com/lib/view/open1328069733264.html)\n\n- ### 统计代码行数\n```\ngit log --author=\"andy.zhen\" --since ==2019-6-24 --until=2019-6-29 --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' -\n```\n\n- ### 查看操作记录\n可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录\n```\n$ git reflog \n```\t\n\n# 分支\n```\n$ git checkout <name>\n\t切换分支\n$ git checkout -b <name>\n\t创建+切换分支\n$ git checkout -b [分支名] [远程名]/[分支名]\n$ git checkout -b sf origin/serverfix\n\t现在你的本地分支 sf 会自动向 origin/serverfix 推送和抓取数据了\n\n$ git branch\n\t查看分支\n$ git branch <name>\n\t创建分支\n$ git branch -v\n\t查看各个分支最后一个提交对象的信息\n$ git branch --merged\n\t查看哪些分支已被并入当前分支\n$ git branch --no-merged\n\t查看还未合并进来的分支\n$ git branch -d <name>\n\t删除本地分支\n$ git branch -D <name>\n\t强制删除本地分支\n$ git branch --set-upstream-to=origin/[远程分支名]  [本地分支名]\n\t设置本地分支与远程分支的映射关系\n\n$ git merge <name>\n\t合并某分支到当前分支\n```\n\n\n# 暂存\n- ### 暂存区\n```\n$ git add <file>\n\t将修改添加到暂存区\n$ git add .\n\t将所有修改添加到暂存区\n\n$ git checkout -- <file>\n\t丢弃未暂存的某个文件的修改\n$ git checkout .\n\t丢弃未暂存的所有文件的修改\n\n$ git reset HEAD <file>\n\t取消已经暂存的文件\n$ git reset --hard HEAD^\n\t撤销本地的上一次提交，\n\t--hard 源码也会回退到某个版本，commit和index 都回回退到某个版本。（注意，这种方式是改变本地代码仓库源码）\n\t--soft 保留源码，只回退到commit 信息到某个版本，不涉及index的回退，如果还需要提交，直接commit即可\n\tHRAD^ 表示上一个提交，HEAD^^ 表示上上个提交，也可表示为 HEAD~2，以此类推\n\tgit revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。reset 是在正常的commit历史中，删除了指定的commit，这时 HEAD 是向后移动了，而 revert 是在正常的commit历史中再commit一次，只不过是反向提交，他的 HEAD 是一直向前的\n```\n【参考】[git reset revert 回退回滚取消提交返回上一版本](http://yijiebuyi.com/blog/8f985d539566d0bf3b804df6be4e0c90.html)\n\n- ### diff\n```\n$ git diff\n\t查看未暂存的更新\n$ git diff --cached\n\t查看已暂存的更新\n$ git diff HEAD -- <name>\n\t查看工作区和版本库里面最新版本的区别\n```\n\n- ### 查看配置信息\n```\n$ git config --list\n```\n\t\n- ### 保存未提交的修改\ngit stash 可用来暂存当前正在进行的工作， 比如想 pull 最新代码， 又不想加新commit， 或者另外一种情况，为了fix 一个紧急的bug,  先stash, 使返回到自己上一个commit, 改完bug之后再stash pop, 继续原来的工作。\n```\n$git stash\n$git stash pop\n$git stash list\n```\n\n- ### 跟踪或取消跟踪文件\n\n1、当被跟踪的文件里面有不想跟踪的文件时，使用命令git rm删除文件。\n```\ngit rm --cached readme1.txt    删除readme1.txt的跟踪，并保留在本地。\ngit rm --f readme1.txt    删除readme1.txt的跟踪，并且删除本地文件。\n然后git commit即可。\n```\n2、每次用git status查看状态时总是列出未被跟踪的文件，可以通过.gitignore文件达到目的。语法如下\n```\n/mtk/ 过滤整个文件夹\n\n*.zip 过滤所有.zip文件\n\n/mtk/do.c 过滤某个具体文件\n```\n3、删除未被跟踪的文件或文件夹\n```\n// 查看将要被删除的未跟踪文件\n$ git clean -n\n// 删除未跟踪文件\n$ git clean -f\n// 如果要操作的对象是文件夹，则在后面加上 -d 参数\n$ git clean -n -d\n$ git clean -f -d\n```\n最后需要强调的一点是，如果你不慎在创建.gitignore文件之前就commit了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。\n***此时要想新的规则生效，需要执行第1种情况里的步骤***\n\n【参考】\n[Git——跟踪或取消跟踪文件](https://www.jianshu.com/p/5cf72a7e2bbf)\n[移除git下的untracked files](https://www.jianshu.com/p/76c93dd3eaad)\n\n\n# 为所欲为的rebase\n```\ngit rebase -i  [startpoint]  [endpoint]\n```\n可以对某一段线性提交历史进行编辑、删除、合并、拆分、重排序等\n**可不指定endpoint，但是startpoint是开集，不包含startpoint的commitid**\n\n```\ngit rebase   [startpoint]   [endpoint]  --onto  [branchName]\n```\n指定当前分支的一个编辑区间(前开后闭)，复制粘贴到指定分支\n这里重点记录一下参考文章中没提到的拆分、重排序操作\n- 一个commit拆分成多个\n```\n1、使用 git rebase -i commitid 后，在需要拆分的 commitid 处，将 pick 修改为 edit 或 e\n2、使用 git reset --soft HEAD^ 将当前 commit 重置到暂存区\n3、将代码分别 commit\n4、执行 git rebase --continue，大功告成\n```\n- commit 重排序\n```\n1、执行 git rebase -i commitid \n2、在编辑区，将几个commit的位置变换。剪切无法使用，只能手工选中、复制、粘贴、删除\n3、保存退出，大功告成\n```\n\n【参考】[【Git】rebase 用法小结](https://www.jianshu.com/p/4a8f4af4e803)\n\n\n# git对象\ntree 对应目录快照，blob 对应文件快照（与文件名无关）\n```\n// 查看对象类型\n$ git cat-file -t objid\n// 查到对象内容\n$ git cat-file -p objid\n```\n\n\n> ## Danger Zone\n【参考】[git同步远程仓库分支](https://www.jianshu.com/p/811b07b129e8)\n\n\n#### 1、本地删除了分支，远程也想删除。\n- 相关命令：\n\n1.删除远程分支: \n```\ngit push origin -d 分支名\n```\n2.删除本地分支: \n```\ngit branch -d 分支名\n```\n- 具体情况：\n\n**a.假如我在本地想要删除某个分支，我也想把远程仓库的这个分支也要删掉怎么办？**\n```\n1.使用git branch -d 分支名来删除本地分支。\n2.使用git push origin -d 分支名直接来删除远程分支。再次使用git branch -a,发现分支已经不存在了。\n\n或者\n\n1.使用git branch -d 分支名来删除本地分支。\n2.最简单的解决办法就是直接到gitlab/github进行删除。\n```\n\n**b.假如我只想把远程的删除掉怎么办？**\n```\n1.使用git push origin -d 分支名直接来删除远程分支。此时删除的只是远程的分支，本地仍然存在\n\n或者\n\n1.直接到gitlab/github进行删除\n```\n\n#### 2、远程删除了分支，本地也想删除\n- 相关命令：\n\n1.查看远程分支和本地分支的对应关系: \n```\ngit remote show origin  \n```\n2.删除远程已经删除过的分支: \n```\ngit remote prune origin\n```\n\n- 具体情况：\n\n假如我直接到 gitlab/github 删除了某个分支，我在本地使用 git branch -a 查看远程分支，依然存在并且可以切换使用。我本地也想把远程分支记录删除怎么办？\n```\n1.git branch -a 查看远程分支，红色的是本地远程远程分支记录。\n2.执行下面命令查看远程仓库分支和本地仓库的远程分支记录的对应关系：\n    git remote show origin  \n3.会看到：refs/remotes/origin/远程仓库已经删除的分支名              stale (use 'git remote prune' to remove)\n    其中：Local refs configured for 'git push':  命令下面的分支是本地仓库的远程分支记录中仍存在的分支，但远程仓库已经不存在。\n4.输入git remote prune origin 来删除远程仓库已经删除过的分支\n5.验证 git branch -a\n\n此时可以看到本地远程分支记录已经和远程仓库保持一致了。\n```\n\n\n\n","tags":["macOS","git"],"categories":["macOS"]},{"title":"presentVC小结","url":"/2022/12/30/iOS/presentVC/","content":"\n# **⚠️⚠️⚠️本文仅讨论 `viewControllerToPresent.modalPresentationStyle = UIModalPresentationOverCurrentContext` 的情况**\n\n### 规则1\n从源VC开始往父VC去找，谁是第一个定义了`self.definesPresentationContext = YES`的，谁就是 presentationContext\n都没找到，那就是 rootVC\n\n### 规则2\n凡是包含在 presentationContext 里的 VC，包括 presentationContext 对应的VC 及其展示出来的子VC，执行 `self.presentedViewController` 都会得到当前被 present 出来的VC\n\n### 规则3\n当被 present 出来的VC present 和 dismiss 后，凡是包含在 presentationContext 里的 VC，包括 presentationContext 对应的VC 及其展示出来的子VC\n⚠️⚠️⚠️都***不会触发*** `viewWillAppear` 和 `viewWillDisappear` 方法\n\n当modalPresentationStyle为UIModalPresentationFullScreen、UIModalPresentationOverFullScreen等模式时，才会触发\n\n\n\n> UIKit搜索presentation context的顺序为： \n> 1. presenting VC \n> 2. presenting VC 的父VC \n> 3. presenting VC 所属的container VC \n> 4. rootViewController\n> \n> 还有另外一种特殊情况，当我们在一个presented VC上再present一个VC时，UIKit会直接将这个presented VC做为presentation context。\n\n\n\n【参考】\n[详解iOS的presentViewController](https://blog.csdn.net/tianweitao/article/details/80314598)\n","tags":["iOS","UIKit"],"categories":["iOS"]},{"title":"cocoapods安装与使用小结","url":"/2022/12/30/iOS/cocoapods_install_use/","content":"\n### 一、安装\n\n#### 1、更新Ruby \n> 安装需要用到Ruby，虽然Mac自带了Ruby，不过版本有点老了，最好更新一下。（测试不更新也是可以的）\n\n- 查看当前Ruby版本\n```\ngem --version\n```\n\n- 更换源（因为Ruby的软件源rubygems.org被屏蔽了，国内那无形之墙，我们需要来修改更换源，把源切换至ruby-china；网上大多数是使用的[https://ruby.taobao.org](https://link.jianshu.com/?t=https://ruby.taobao.org)的，这里不再建议使用的了，这是因为taobao Gems 源已停止维护，现由 ruby-china 提供镜像服务）\n```\ngem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/\n```\n【2020.9.5更新】`gems.ruby-china.org` 不好用了， 可用的源为：`https://mirrors.tuna.tsinghua.edu.cn/rubygems/`\n\n- 查看源路径是否替换成功。请确保只有 gems.ruby-china.org! *，然后方可更新Ruby\n```\ngem sources -l\n```\n\n- 更新Ruby\n```\nsudo gem update --system\n```\n\n\n#### 2、安装Cocoapods\n\n- 安装Cocoapods\n```\nsudo gem install cocoapods\n```\n如果出现以下报错：\n![来自本人电脑](/images/iOS/cocoapods_install_use/01.png)\n修改安装命令为：\n```\nsudo gem install -n /usr/local/bin cocoapods\n```\n\n- 查看版本号\n```\npod --version\n```\n\n- 设置官方仓库源\n```\npod setup\n```\n\n- 卸载当前版本\n```\nsudo gem uninstall cocoapods\n```\n\n- 下载指定版本\n```\nsudo gem install cocoapods -v 1.6.1\n```\n\n\n\n### 二、私有源\n\n- 查看本地已存在的仓库源\n```\npod repo list\n```\n\n- 添加私有仓库（私有Spec Repo）\n此命令不仅仅添加对应的私有仓库源，还会将源都clone到本地\n```\npod repo add [私有Pod源仓库名字] [私有Pod源的repo地址]\n```\n\n- 删除私有仓库（私有Spec Repo）\nclone 到本地的所有库文件都会同时删除\n```\npod repo remove [私有Pod源仓库名字]\n```\n\n### 三、更新podspec \n\n- 添加tag\n```\ngit tag 0.0.1  //要跟podspec中的version保持一致\n```\n\n- 推送tag\n```\ngit push origin master --tags\n```\n\n- 验证修改后的仓库和仓库对应的podspec文件\n在当前仓库代码下执行\n```\npod lib lint --allow-warnings\n```\n\n- 本地测试podspec文件\n```\nplatform :ios, '7.0'\n\npod 'PodTestLibrary', :path => '~/code/Cocoapods/podTest/PodTestLibrary'      # 指定路径\npod 'PodTestLibrary', :podspec => '~/code/Cocoapods/podTest/PodTestLibrary/PodTestLibrary.podspec'  # 指定podspec文件\n```\n\n- 向Spec Repo提交podspec\n```\npod repo push WTSpecs PodTestLibrary.podspec  #前面是本地Repo名字 后面是podspec名字\n```\n如果遇到警告，也可以在后面添加命令参数 `--allow-warnings`\n```\npod repo push WTSpecs PodTestLibrary.podspec --allow-warnings\n```\n\n\n### 四、在单元测试工程target中集成pod库\n1、修改podfile文件，增加以下配置\n```\ntarget 'XXXProjectTests' do\n  \n  pod 'XXXSDK'\nend\n``` \n2、关闭当前工程的xcode窗口，删除当前工程的 workspace 文件，然后重新执行 `pod install` 。执行成功后，会在pod工程下的 `Target Support Files` 下生成 `pod-xxxxTests` 文件夹\n\n\n### 五、常见问题\n**1、`pod repo update master` 因速度非常慢而更新失败**\n解决方案：\n1、开启翻墙代理\n2、电脑连手机4g热点\n3、设置git全局代理为翻墙代理\n```\ngit config --global http.proxy socks5://127.0.0.1:1086\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:1086\n```\n注意，上面的端口号是自己的代理的端口\n![shadow socks高级设置](/images/iOS/cocoapods_install_use/02.png)\n4、执行pod update，binggo\n【参考】[pod repo update速度慢](https://www.jianshu.com/p/bf26e92ec5b1)\n\n\n### 参考链接\n1、[最新cocoapods详细安装](https://www.jianshu.com/p/1e7ab521000b)\n2、[组件化和私有pod源仓库](https://www.jianshu.com/p/83dc05c19c9f)\n3、[使用Cocoapods创建私有podspec](http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/)\n4、[IOS开发中使用单元测试(OCUnit)测试集成pod库工程中的一些问题以及解决方案](https://blog.csdn.net/lwb102063/article/details/98947336)\n\n\n  ","tags":["iOS","cocoapods"],"categories":["iOS"]},{"title":"NSProxy使用小结","url":"/2022/12/30/iOS/nsproxy/","content":"\n- NSProxy 是个虚类，同时是所有虚类的基类，地位类比 NSObject\n\n- NSProxy 提供了 alloc 方法，但是没有提供 init 方法，所有集成它的子类都需要自己实现初始化方法\n\n- NSProxy 主要用于  ***消息转发***  的场景。所以它提供了两个消息转发相关的接口，所有子类都必须实现\n```\n- (void)forwardInvocation:(NSInvocation *)invocation;\n- (nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel;\n```\n\n- 当定义的protocol在一个独立的头文件时，proxy 声明实现它但是没有提供真正的实现方法时，编译器不会报错\n\n【参考】\n1、[NSProxy](https://blog.csdn.net/u014084081/article/details/77084356)\n2、[NSProxy——少见却神奇的类](https://www.jianshu.com/p/8e700673202b)","tags":["iOS","Foundation"],"categories":["iOS"]},{"title":"HTTPS第四次握手总结","url":"/2022/12/30/iOS/https_ssl_handshake/","content":"\n目标：安全\n关键字：SSL/TLS\n关键算法：hash，对称加密，非对称加密\n关键点：对称密钥的生成和传输\n\n所以整个网络数据包的安全性转化成了**对称密钥的安全性**，为了达到此目的，采用以下措施：\n***1、随机数***：3个随机数，防止暴力破解\n***2、加密算法***：server需在client支持的算法列表中挑选一个\n***3、传输安全性***：对称密钥不在网络中传输，而改为传输随机数，然后双方用协商好的算法各自生成相同的对称密钥\n\n### 综上，SSL握手的过程如下：\n#### hello阶段\n1、client发送ssl版本号、支持的算法列表、随机数random1给server\n2、server发送选中的算法、随机数random2给client\n3、server发送自身证书（包含非对称公钥）给client\n4、server发送确认消息给client，告知握手消息发送完成\n\n#### exchange阶段\n5、client验证server证书\n6、client生成随机数random3，并计算pre-master key（使用server的公钥加密）给server。server解密得到随机数random3，通过计算random1、2、3得到对称密钥key\n\n#### test阶段\n7、client向server发送明文消息，标明之后发的消息开始启用加密\n8、client向server发送密文消息\n9、server解密成功后也向client发送步骤7一样的消息\n10、server向client发送密文消息\n11、应用数据加密传输\n\n\n\n### 中间人攻击原理：\n1、将自己伪装成client跟server握手并通讯\n2、将自己伪装成server跟client握手并通讯\n\n由于现在大部分HTTPS都是单向认证，即只有client验证server，server不验证client，所以第一点无压力，关键在于第二点，伪装成server的时候如何让client验证通过，只要client信任了自己下发的证书，就可以顺利解密client发给server的密文了。这也是为什么抓包工具在抓HTTPS的包时一定要安装并信任它的证书。\n\n\n参考：\n[SSL/TLS 握手过程详解](https://www.jianshu.com/p/7158568e4867)\n[浅析HTTPS中间人攻击与证书校验](https://www.2cto.com/article/201607/523509.html)\n","tags":["iOS","HTTPS"],"categories":["iOS"]},{"title":"不阻塞线程的另一种技巧","url":"/2022/12/30/iOS/thread_idle_async/","content":"\n### 思路：\n在线程空闲时去执行\n\n### 方案：\n利用通知队列 `NSNotificationQueue ` 在线程空余时 `NSPostWhenIdle ` 去发送一个通知，在接收者那里执行相应的代码\n\n### 示例：\n```\ninline void __onMainThreadAsync(void (^block)()) {\n    if ([NSThread isMainThread]) {\n        block();\n    } else {\n        dispatch_async(dispatch_get_main_queue(), block);\n    }\n}\n\ninline void __onIdleThreadAsync(void (^block)()) {\n    __onMainThreadAsync(^{\n        CFUUIDRef uuidRef = CFUUIDCreate(NULL);\n        CFStringRef uuidStringRef = CFUUIDCreateString(NULL, uuidRef);\n        CFRelease(uuidRef);\n        NSString *uuidValue = (__bridge_transfer NSString *)uuidStringRef;\n        NSString *name = [NSString stringWithFormat:@\"EnqueueIdleThreadNotification_%@\", uuidValue];\n        NSNotification *notification = [NSNotification notificationWithName:name object:nil];\n        NSNotificationCenter * __block center = [NSNotificationCenter defaultCenter];\n        id __block token = [center addObserverForName:name object:nil queue:[NSOperationQueue currentQueue] usingBlock:^(NSNotification * _Nonnull note) {\n            block();\n            [center removeObserver:token];\n            token = nil;\n            center = nil;\n        }];\n        [[NSNotificationQueue defaultQueue] enqueueNotification:notification postingStyle:NSPostWhenIdle];\n    });\n}\n```\n\n### 适用场景：\n比如app启动时一些第三方库的初始化工作，必须在主线程执行但又不能阻塞主线程当前执行的代码\n\n### 参考：\n1、[深入思考NSNotification](https://www.jianshu.com/p/3012b863befb)","tags":["iOS","多线程"],"categories":["iOS"]},{"title":"关于UIWindow","url":"/2022/12/30/iOS/uiwindow/","content":"\n### iOS系统差异\napp有多个 `window` 对象时，并且`keywindow` 不是根`window`时，一些第三方自定义键盘（不是搜狗那种第三方系统键盘类型）\niOS9、10：可以显示\niOS11、12：不可显示\n\n### 根window\napp启动时创建的第一个window，亦可称为mainwindow\n获取方法：\n```\n[UIApplication sharedApplication].delegate.window\n[UIApplication sharedApplication].windows.firstObject\n```\n以下两种获取方法不一定准确：\n```\n[UIApplication sharedApplication].keyWindow\nself.view.window  \n```\n\n### 自定义window\n显示出来的方法：`[myWindow makeKeyAndVisible]` 或者 `myWindow.hidden = NO`\n自定义window在hidden后，keywindow会自动重置为根window\n\n### 系统alert\n系统alert弹出时，会新建一个window，同时设为key并显示，dismiss后，keywindow会自动重置为根window\n","tags":["iOS","UIKit"],"categories":["iOS"]},{"title":"常用的加解密算法原理","url":"/2022/12/30/iOS/encode_theory/","content":"\n## 对称加密算法\n\n**经典算法：**\n- DES 数据加密标准\n- 3DES 使用3个密钥，对消息进行（密钥1·加密）+（密钥2·解密）+（密钥3·加密）\n- AES 高级加密标准\n\n**分组模式：主要有两种**\n\n- ECB模式(又称电子密码本模式)\n  使用ECB模式加密的时候，相同的明文分组会被转换为相同的密文分组。\n  类似于一个巨大的明文分组 -> 密文分组的对照表。\n\n\n![](/images/iOS/encode_theory/01.jpg)\n\n  **某一块分组被修改，不影响后面的加密结果**\n\n- CBC模式(又称电子密码链条)\n  在CBC模式中，首先将明文分组与前一个密文分组进行XOR(异或)运算，然后再进行加密。\n  每一个分组的加密结果依赖需要与前一个进行异或运算，由于第一个分组没有前一个分组，所以需要提供一个初始向量iv\n\n![](/images/iOS/encode_theory/02.jpg)\n\n**某一块分组被修改，影响后面的加密结果**\n\n\n## 非对称加密\n\n**RSA算法原理**\n```\n* 求N，准备两个质数p和q,N = p x q\n* 求L,L是p-1和q-1的最小公倍数。L = lcm（p-1,q-1）\n* 求E，E和L的最大公约数为1（E和L互质）\n* 求D，E x D mode L = 1\n```\n\n**RSA加密实践**\n```\n* p = 17,q = 19 =>N = 323\n* lcm（p-1,q-1）=>lcm（16，18）=>L= 144\n* gcd（E,L）=1 =>E=5\n* E乘以几可以mode L =1? D=29可以满足\n* 得到公钥为：E=5,N=323\n* 得到私钥为：D=29,N=323\n* 加密 明文的E次方 mod N = 123的5次方 mod 323 = 225（密文）\n* 解密 密文的D次方 mod N = 225的29次方 mod 323 = 123（明文）\n```\n\n**DH密钥交换算法**\n迪菲－赫尔曼密钥交换（Diffie–Hellman key exchange，简称“D–H”） 是一种安全协议。\n它可以让双方在完全没有对方任何预先信息的条件下通过不安全信道建立起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。\n- 算法原理及证明过程如下：\n![](/images/iOS/encode_theory/03.jpg)\n【注】DH算法也并不能避免中间人攻击，要想避免，还是得需要验证双方身份，即证书\n\n\n**相关demo**\n[RSADemo](https://github.com/aaszjp/RSADemo)\n\n\n### 参考文献\n[1][数据安全及各种加密算法对比](https://www.jianshu.com/p/b44927161081)\n[2][DH密钥交换算法](https://blog.csdn.net/fw0124/article/details/8462373)\n[3][带你彻底理解RSA算法原理](https://blog.csdn.net/dbs1215/article/details/48953589)\n[4][RSA算法原理——（2）RSA简介及基础数论知识](https://blog.csdn.net/u014044812/article/details/80782448)\n[5][RSA算法原理——（3）RSA加解密过程及公式论证](https://blog.csdn.net/u014044812/article/details/80866759)","tags":["iOS","加密算法"],"categories":["iOS"]},{"title":"iOS语法糖","url":"/2022/12/30/iOS/iOS_syntax_sugar/","content":"\n### 给一个对象赋值，常见的写法\n```\nself.imageView = [[UIImageView alloc] init];  \nself.imageView.backgroundColor = [UIColor redColor];  \nself.imageView.image = [UIImage imageNamed:@\"12345\"];  \nself.imageView.frame = CGRectMake(0, 0, 100, 100);\n```\n\n### 语法糖\n```\nself.imageView = ({ \n    UIImageView *imageView = [[UIImageView alloc] init];    \n    imageView.backgroundColor = [UIColor redColor];  \n    imageView.image = [UIImage imageNamed:@\"12345\"];  \n    imageView.frame = CGRectMake(0, 0, 100, 100);    \n    imageView;  \n});\n```\nPS: 返回值和代码块结束点必须在结尾\n\n### block\n```\nself.imageView = ^(){\n    UIImageView *imageView = [[UIImageView alloc] init];    \n    imageView.backgroundColor = [UIColor redColor];  \n    imageView.image = [UIImage imageNamed:@\"12345\"];  \n    imageView.frame = CGRectMake(0, 0, 100, 100);    \n    return imageView;  \n}();\n```\n### 语法糖和block写法的好处\n&emsp;&emsp;最大的意义在于将代码整理分块，将同一个逻辑层级的代码包在一起；同时对于一个无需复用的小段逻辑，也免去了重量级的调用函数，这样使得代码量增大时层次仍然能比较明确。\n\n### 参考\n[objc非主流代码技巧](http://blog.sunnyxx.com/2014/08/02/objc-weird-code/)\n[iOS语法糖 -- 简约而不简单](https://www.jianshu.com/p/3f7b3c2d9ef3)\n【block写法暂未找到参考，但是可成功运行】\n","tags":["iOS","OC"],"categories":["iOS"]},{"title":"Mac磁盘空间清理","url":"/2022/12/30/macOS/mac_disk_clean/","content":"\n### 大部分的缓存文件都是由xcode生成，清理xcode的缓存文件可以至少清理出几十g的空间。\n\n- 1、移除对旧设备的支持(iOS DeviceSupport)\n一般是占用内存空间最大的文件夹，即使全部删，再连接设备调试时，会重新自动生成。一般iOS只向下兼容两个版本就可以了\n路径：\n```\n~/Library/Developer/Xcode/iOS DeviceSupport\n```\n释放空间：一个版本2-3G * 版本数\n建议：可以全部删除\n本人操作：把除了当前版本（iOS12.2）以外的所有版本，最早到iOS 8，全部删掉，释放空间71G\n\n【参考】\n1、[Mac空间清理](https://blog.csdn.net/dangyalingengjia/article/details/79018560)\n","tags":["macOS"],"categories":["macOS"]},{"title":"Mac奇淫异巧","url":"/2022/12/30/macOS/mac_skill/","content":"\n### 1、 macOS 打开软件或可执行程序，显示已损坏或无法验证此App不包含恶意软件 \nMacOS 10.14 及以下，禁用 gatekeeper\n```\nsudo spctl --master-disable\n```\nMacOS 10.15 及以上，除了禁用gatekeeper，还需绕过公证\n```\nsudo xattr -rd com.apple.quarantine /Applications/xxxxxx.app\n```\n[macOS 10.15 Catalina xxx.app已损坏，无法打开，你应该将它移到废纸篓解决方法](https://macwk.com/article/mac-catalina-1015-file-damage)\n\n\n### 2、Mac远程到Mac的方法，无需下载第三方软件\n在A机器【设置】-->【共享】中打开【屏幕共享】，然后在B机器，使用spotlight搜索“屏幕共享”，打开屏幕共享程序，输入以下命令，即可远程到A机器进行任意操作\n```\nvnc://A机器的ip\n```\n\n","tags":["macOS"],"categories":["macOS"]},{"title":"使用shell配置代理切换工具","url":"/2022/12/30/macOS/wifi_proxy/","content":"\n1、编写文件`.wifi-proxy.bash`文件如下：\n\n```\nwifi-proxy-off () {\n\tsudo networksetup -setftpproxystate Wi-Fi off\n\tsudo networksetup -setwebproxystate Wi-Fi off\n\tsudo networksetup -setsecurewebproxystate Wi-Fi off\n\tsudo networksetup -setstreamingproxystate Wi-Fi off\n\tsudo networksetup -setgopherproxystate Wi-Fi off\n\tsudo networksetup -setsocksfirewallproxystate Wi-Fi off\n\tsudo networksetup -setautoproxystate Wi-Fi off\n}\n\nwifi-proxy-on () {\n\tsudo networksetup -setwebproxystate Wi-Fi on\n\tsudo networksetup -setsecurewebproxystate Wi-Fi on\n\tsudo networksetup -setwebproxy Wi-Fi 127.0.0.1 8899\n\tsudo networksetup -setsecurewebproxy Wi-Fi 127.0.0.1 8899\n}\n```\n\n2、将文件保存到路径 `~/` 下，为 `~/.wifi-proxy.bash`\n\n3、修改 `~/.bashrc` 文件，增加一行 ，并保存\n```\nsource ~/.wifi-proxy.bash\n```\n\n4、命令行执行 `source ~/.bashrc`\n\n5、命令行执行 `wifi-proxy-off` or  `wifi-proxy-on` 即可\n\n6、enjoy\n\n**【注意】要想不用每次启动bash命令行，就改为在 `~/.bash_profile` 中增加响应内容，然后再source它**\n\n\n#### 参考\n1、[OSX 下面用 networksetup 切换代理](https://www.v2ex.com/t/158198)\n2、[@Shell 的两种启动方式以及环境变量的配置](https://www.jianshu.com/p/d872f02f91a0)","tags":["macOS"],"categories":["macOS"]},{"title":"在Mac下配置环境变量","url":"/2022/12/30/macOS/mac_env/","content":"\n### 理论\n#### 1./etc/profile   （建议不修改这个文件 )\n全局（公有）配置，不管是哪个用户，登录时都会读取该文件。\n#### 2./etc/bashrc    （一般在这个文件中添加系统级环境变量）\n全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。\n#### 3.~/.bash_profile  （一般在这个文件中添加用户级环境变量）\n每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!\n\n\n\n### 示例：\n1、执行： vim ~/.bash_profile \n2、在最末添加行：export PATH=\"你的新路径:$PATH\"\n3、退出vim编辑器并保存\n4、执行 source ~/.bash_profile\n\n#### 参考\n1、[Mac 可设置环境变量的位置、查看和添加PATH环境变量](https://www.jianshu.com/p/2b5305fd2640)","tags":["macOS"],"categories":["macOS"]},{"title":"GIT 自动补全命令,分支名 以及 高亮显示当前分支","url":"/2022/12/30/macOS/git_auto_cmd/","content":"\n【注】`~/.bashrc` 是Linux的，对应到Mac OSX 是 `~/.bash_profile` ，看网上的教程要注意区分和替换\n\n### 1、执行以下命令，克隆官方git库，然后找到两个关键文件\n`git clone git@github.com:git/git.git`\n- `contrib/completion/git-completion.bash` 自动补全\n- `contrib/completion/git-prompt.sh` 高亮显示当前分支名称\n\n### 2、执行以下命令，将两个文件复制到用户目录，并设置隐藏\n`cp git-completion.bash ~/.git-completion.bash`\n`cp git-prompt.sh ~/.git-prompt.sh`\n\n### 3、配置 `~/.bash_profile` 文件，没有该文件就新增，然后加入以下内容\n```\n# git命令自动补全\nsource ~/.git-completion.bash\n# git显示分支官方实现\nGIT_PS1_SHOWDIRTYSTATE=true\nGIT_PS1_SHOWCOLORHINTS=true\nGIT_PS1_SHOWSTASHSTATE=true\nGIT_PS1_SHOWUNTRACKEDFILES=true\n#GIT_PS1_SHOWUPSTREAM=auto           \nif [ -f ~/.git-completion.bash ]; then\n  source ~/.git-prompt.sh\n  PROMPT_COMMAND='__git_ps1 \"[\\t][\\u@\\h:\\w]\" \"\\\\\\$ \"'\nfi\n```\n\n### 4、执行以下命令进行刷新\n`source ~/.bash_profile`\n\n### 5、bingo，enjoy！\n\n#### 【PS：有一个大坑需要注意】\n官方的 `git-completion.bash` 文件在 `2289880f784326dc955f213072164539dcaf445e` 提交节点下有问题，无法使用。折腾了好久，最后使用[旧版的文件](https://www.jianshu.com/writer#/notebooks/16792301/notes/29257216)可以使用。\n\n#### 【2019.5.10更新：大坑已修复】\n迄今为止最新的commit（`01f8d78887d45dc10f29d3926d5cc52f78838846`）已经可以在（`MacOS Mojave 10.14.4`） 下正常使用\n\n#### 【2020.4.22更新】\nMac OS Catalina 10.15.2 中，终端默认使用的shell脚本是zsh，不是bash。这会导致上面第4步执行失败，报错如下：\n```\nWARNING: this script is deprecated, please see git-completion.zsh\n```\n但是Git并没有兼容zsh，所以还是得用回bash。解决办法如下：\n终端 --> 偏好设置 --> 通用 --> Shell的打开方式，选中【命令（完整的路径）】，设置为：/bin/bash\n\n![](/images/macOS/git_auto_cmd/01.png)\n\n\n\n#### 参考\n1、[GIT 自动补全命令,分支名 以及 高亮显示当前分支](https://blog.csdn.net/weixin_36372074/article/details/73612496)\n2、[修改 .bash_profile(mac) 或 .bashrc(linux) 让 terminal 能自动补全 git 命令、显示 git 分支等信息 (git-completion.bash 和 git-prompt.sh 放入 ~ 目录)](https://gist.github.com/xhlwill/688c92d8a6026085fffe4ab6c97855ae)\n3、[Mac下git命令自动补全](https://blog.csdn.net/zhangt85/article/details/43611997)","tags":["macOS","git"],"categories":["macOS","git"]},{"title":"Hello World","url":"/2022/12/28/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]